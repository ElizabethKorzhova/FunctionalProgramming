(use data.queue) ; імпортуємо бібліотеку для роботи з чергами
(let ((n 10) (t1 20) (t2 10) (T 100)) ; задаємо початкові умови
    (let ((t1-c t1) (t2-c t2) (queue (list->queue (iota n 1))) (T-c T)) ; копіюємо початкові умови та створюємо чергу з n елементів
        (define (loop-q) ; функція, яка імітує цикл
            (let ((t (min t1-c t2-c))) ; визначаємо, щог відбудеться раніше, прийде чи уйде людина, або ж одночасно
                (set! T-c (- T-c t)) ; віднімаємо від загального часу програми час, який пройде до наступної події
                (if (< T-c 0) ; якщо він менший за нуль, то подія недосяжна
                    (display "Робочий день завершено!") ; виводимо відповідне повідомлення
                    (begin ; робимо візуалізуємо подію
                        (if (and (= t1-c t) (not (queue-empty? queue))) ; якщо найближча подія - це уход людини та черга не пуста, відпускаємо людину та виводимо відповідне повідомлення
                            (begin
                                (display (- T T-c))
                                (display ": Покупець ")
                                (display (dequeue! queue))
                                (display " був обслугований\n")
                            )
                        )
                        (if (= t2-c t) ; якщо найближча подія - це приход людини, то ставимо її у кінець черги
                            (begin
                                (enqueue! queue (if (queue-empty? queue) 1 (+ 1 (queue-rear queue)))) ; якщо черга порожня, то індексувати людину почнемо з одиниці, інакше додамо одиницю до останнього індексу в черзі
                                (display (- T T-c))
                                (display ": Покупець ")
                                (display (queue-rear queue))
                                (display " прийшов до черги\n")
                            )
                        )
                        (set! t1-c (- t1-c t)) ; віднімемо пройдений час від часу, через який людина має піти
                        (set! t2-c (- t2-c t)) ; відмимемо пройдений час від часу, через який людина має прийти
                        (if (= t1-c 0) (set! t1-c t1)) ; якщо такий час дорівнює нулю, то людина пішла і чекаємо, коли піде нова
                        (if (= t2-c 0) (set! t2-c t2)) ; якщо такий час дорівнює нулю, то людина прийшла и чекаємо на нову
                        (display "Стан черги: ")
                        (display (queue->list queue)) ; виводимо стан черги
                        (newline)
                        (newline)
                        (loop-q) ; викликаємо наступну подію
                    )
                )
            )
        )
        (display "0: Стан черги на початку: ")
        (display (queue->list queue)) ; виводимо початковий стан черги
        (newline)
        (newline)
        (loop-q) ; перший виклик функції, яка імітує події
    )
)